/*
 * Copyright (c) 2020 Microsoft. All rights reserved.
 */

// This tool takes an image binary as input and generates the UNSIGNED image
// header for it. It excludes the signature field, which is the last one in the
// header. That field must be generated by signtool.
//
// It is needed to provide the firmware version to this tool so that it is saved
// in the header. The version must be a decimal number.
//
// For example, to generate the header of L1 for the version 12345678:
//
//     headertool 12345678 L1_Image.bin L1_Header.bin
//
// To generate the one of L0 it is needed to include the offset to L1 (if it is
// located 128 KB after L0):
//
//     headertool 12345678 L0_Image.bin L0_Header.bin 131072

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "crypto/ImageSigning.h"
#include "fw/common/image_header.h"

#include "header_utils.h"

static void load_file(const char *path, void **buffer, size_t *size) {
  // Make sure that the output pointers are valid
  assert(path);
  assert(buffer);
  assert(size);

  FILE *f = fopen(path, "rb");
  if (f == NULL) {
    printf("Couldn't open %s\n", path);
    exit(EXIT_FAILURE);
  }

  fseek(f, 0, SEEK_END);
  *size = ftell(f);

  if (*size == 0) {
    printf("File is empty: %s\n", path);
    fclose(f);
    exit(EXIT_FAILURE);
  }

  rewind(f);
  *buffer = malloc(*size);

  if (*buffer == NULL) {
    printf("Couldn't allocate space for: %s\n", path);
    fclose(f);
    exit(EXIT_FAILURE);
  }

  if (fread(*buffer, *size, 1, f) != 1) {
    printf("Couldn't read %s\n", path);
    fclose(f);
    exit(EXIT_FAILURE);
  }

  fclose(f);
}

static int save_header(const char *path, uint32_t version, void *fw_data,
                       uint32_t fw_size, uint32_t next_image_offset) {
  assert(path);
  assert(fw_data);

  image_header_t header;

  int ret =
      image_header_build(&header, version, fw_data, fw_size, next_image_offset);
  if (ret != 0) {
    printf("Couldn't generate header\n");
    return -1;
  }

  FILE *f = fopen(path, "wb");
  if (f == NULL) {
    printf("Couldn't open %s for writing\n", path);
    return -1;
  }

  // Save header without signature
  size_t out_size = sizeof(image_header_t) - sizeof(header.header_signature);

  if (fwrite(&header, out_size, 1, f) != 1) {
    printf("Failed to write data to %s\n", path);
    fclose(f);
    return -1;
  }

  fclose(f);

  return 0;
}

static void print_usage(const char *argv0) {
  printf("Usage: %s fw_version input_image.bin output_header.bin \n"
         "               [next_image_offset]\n",
         argv0);
}

int main(int argc, char *argv[]) {
  if (argc != 4 && argc != 5) {
    printf("Invalid number of arguments.\n");
    print_usage(argv[0]);
    exit(EXIT_FAILURE);
  }

  unsigned int version = 0;

  if (sscanf(argv[1], "%u", &version) != 1) {
    printf("Invalid version number\n");
    print_usage(argv[0]);
    exit(EXIT_FAILURE);
  }

  const char *input_path = argv[2];
  const char *output_path = argv[3];

  void *input_file;
  size_t input_file_size;
  load_file(input_path, &input_file, &input_file_size);

  unsigned int next_image_offset = 0;

  if (argc == 5) {
    // If we have information about next image, add it.
    if (sscanf(argv[4], "%u", &next_image_offset) != 1) {
      printf("Invalid next image offset\n");
      print_usage(argv[0]);
      exit(EXIT_FAILURE);
    }
  }

  if (save_header(output_path, version, input_file, input_file_size,
                  next_image_offset) != 0) {
    free(input_file);
    exit(EXIT_FAILURE);
  }

  free(input_file);

  exit(EXIT_SUCCESS);
}
